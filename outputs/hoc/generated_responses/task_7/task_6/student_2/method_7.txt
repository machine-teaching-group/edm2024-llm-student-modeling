You are working on the visual programming domain Classic Maze Challenge from https://code.org/ 
In this domain, the following types of coding blocks are available.
- Basic navigation blocks: moveForward, turnLeft, turnRight.
- Boolean conditions: pathAhead, pathLeft, pathRight, goal
- Loops: RepeatUntil(boolean){}
- Conditionals: If(boolean){}, If(boolean){}Else{}.

A task is represented as a 10x10 visual grid.
This grid contains WALL cells, FREE cells, a GOAL cell, and an AVATAR (with specific location and direction).
We represent a task's 10x10 visual grid with the following symbols.
'#' represents a WALL cell.
'+' represents the GOAL cell.
'>' represents AVATAR's location on a cell, facing East direction.
'<' represents AVATAR's location on a cell, facing West direction.
'^' represents AVATAR's location on a cell, facing North direction.
'v' represents AVATAR's location on a cell, facing South direction.
A solution code for a task brings the AVATAR to the GOAL when executed. Note that the AVATAR can only move between FREE cells and will crash if it tries to go to a WALL cell.

First, I give you below a reference task, its solution code, and an attempt code from a student on the reference task. Observe and explain the student's behavior and misconceptions in the attempt code.

Second, I give you a new target task with its solution code. You are going to play the role of the given student. Synthesize an attempt code that is likely to be written by the same student, i.e capturing the student's behavior and misconceptions shown on the reference task.

--- Reference Task 1: Grid ---
1	#	#	#	#	#	#	#	#	#	#	
2	#	#	#	#	#	#	#	#	#	#	
3	#	#	#	#	#	#	#	#	#	#	
4	#	#	.	#	#	#	#	#	#	#	
5	+	.	.	.	.	.	.	#	#	#	
6	#	#	#	.	#	#	.	#	#	#	
7	#	#	#	.	#	#	.	#	#	#	
8	#	#	#	#	#	#	.	#	#	#	
9	#	#	#	#	#	>	.	#	#	#	
10	#	#	#	#	#	#	#	#	#	#	

--- Reference Task 1: Solution ---
def Run(){
	RepeatUntil(goal){
		If(pathAhead){
			moveForward
		}
		Else{
			turnLeft
		}
	}
}

--- Reference Task 1: Student attempt ---
def Run(){
	RepeatUntil(goal){
		If(pathAhead){
			moveForward
		}
		Else{
			turnRight
		}
	}
}

--- Target Task 1: Grid ---
1	#	#	#	#	#	#	#	#	#	#	
2	#	#	#	#	#	#	#	#	#	#	
3	#	#	#	.	#	#	#	#	#	#	
4	#	#	#	.	#	#	#	#	#	#	
5	#	#	#	.	#	#	#	#	#	#	
6	.	.	.	.	.	.	#	#	#	#	
7	#	.	#	#	#	.	#	#	#	#	
8	#	.	#	+	#	.	#	#	#	#	
9	#	.	.	.	#	^	#	#	#	#	
10	#	#	#	#	#	#	#	#	#	#	

--- Target Task 1: Solution ---
def Run(){
	RepeatUntil(goal){
		If(pathLeft){
			turnLeft
			moveForward
		}
		Else{
			moveForward
		}
	}
}

--- Target Task 1: Student attempt ---
Great! Let's dive into the task and provide explanations for the student's attempt code.
Reference Task 1:
The student's attempt code for the reference task is as follows:
def Run(){
RepeatUntil(goal){
If(pathAhead){
moveForward




            }
            Else{
                    turnRight

            }
    }
}

The student's code is similar to the solution code, but there are some notable differences:

The student uses RepeatUntil(goal) instead of RepeatUntil(pathAhead). This is a common mistake made by students, as they misunderstand the logic of the RepeatUntil block. The RepeatUntil block should be used to repeat a block of code until a specific condition is met, and the student's code will repeat the moveForward or turnRight instructions until the goal is reached, rather than until the path ahead is clear.
The student does not use the moveForward or turnRight blocks correctly. In the reference task, the student's code moves the avatar forward or turns right only when the path ahead is clear, but the student's code always moves the avatar forward or turns right, regardless of the path ahead. This will cause the avatar to crash into walls or get stuck in corners.
Target Task 1:
The student's attempt code for the target task is as follows:
def Run(){
RepeatUntil(goal){
If(pathLeft){
turnLeft

moveForward

}
Else{
moveForward

}
}
}

The student's code for the target task is similar to their code for the reference task, but there are some additional mistakes:

The student uses RepeatUntil(goal) instead of RepeatUntil(pathLeft). This is another common mistake made by students, as they misunderstand the logic of the RepeatUntil block. The RepeatUntil block should be used to repeat a block of code until a specific condition is met, and the student's code will repeat the `move